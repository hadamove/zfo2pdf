<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ZFO ➡️ PDF</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/forge/1.3.1/forge.min.js"
    integrity="sha512-95iy0RZIbw3H/FgfAj2wnCQJlzFQ+eaSfUeV/l8WVyGHKSRMzm3M/O+85j9ba/HFphkijrCTDjcuDX0BL2lthA=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>

<body class="bg-gray-50 min-h-screen flex flex-col gap-6 py-6"
  style="background-image: radial-gradient(circle, #ddd 1px, transparent 1px), radial-gradient(circle, #ddd 1px, transparent 1px); background-position: 0 0, 5px 5px; background-size: 10px 10px;">

  <h2 class="text-3xl font-semibold mb-4 text-center text-gray-800" style="font-family: 'Poppins', sans-serif;">.ZFO ➡️
    .PDF</h2>

  <div class="text-center max-w-md mx-auto px-8 bg-white py-8 border border-gray-200" style="border-radius: 8px;">
    <ol class="text-left mb-6 space-y-4 text-gray-600 list-decimal list-inside">
      <li><strong>Upload your file:</strong> Click the 'Upload file' button and select the ZFO file you wish to convert.
      </li>
      <li><strong>Convert:</strong> After uploading, click the 'Convert' button to start the conversion process.</li>
      <li><strong>Download:</strong> Once the conversion is complete, you can download your PDF file.</li>
    </ol>
    <div class="flex flex-col gap-4">
      <label for="fileInput"
        class="cursor-pointer py-2 px-4 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 transition duration-150 ease-in-out flex justify-center items-center">
        <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 -960 960 960" width="24" class="mr-2">
          <path
            d="M440-200h80v-167l64 64 56-57-160-160-160 160 57 56 63-63v167ZM240-80q-33 0-56.5-23.5T160-160v-640q0-33 23.5-56.5T240-880h320l240 240v480q0 33-23.5 56.5T720-80H240Zm280-520v-200H240v640h480v-440H520ZM240-800v200-200 640-640Z" />
        </svg>
        Upload file
      </label>
      <input type="file" id="fileInput" class="sr-only" onchange="updateLabel()">
      <button id="transformButton" onclick="transformFile()"
        class="bg-gray-800 text-white py-2 px-4 rounded-md hover:bg-gray-900 transition duration-150 ease-in-out flex justify-center items-center">
        <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 -960 960 960" width="24" fill="white"
          class="mr-2">
          <path
            d="M280-160 80-360l200-200 56 57-103 103h287v80H233l103 103-56 57Zm400-240-56-57 103-103H440v-80h287L624-743l56-57 200 200-200 200Z" />
        </svg>
        Convert
      </button>
    </div>
  </div>

  <footer class="mt-auto py-4 text-center text-sm text-gray-600">
    © 2024 ZFO to PDF Converter
  </footer>

  <script>
    function updateLabel() {
      const input = document.getElementById('fileInput');
      const label = document.querySelector('label[for="fileInput"]');
      const fileName = input.files[0].name;
      label.textContent = fileName ? `File: ${fileName}` : 'Upload file';
    }

    const transformFile = () => {
      const fileInput = document.getElementById('fileInput');

      if (!fileInput.files || fileInput.files.length === 0) {
        return;
      }

      const file = fileInput.files[0];
      const reader = new FileReader();

      reader.onload = function (event) {
        const zfoContent = event.target.result;
        const xmlContent = extractXmlContentFromZfo(zfoContent);
        transformData(xmlContent);
      };

      reader.readAsBinaryString(file);
    }

    const extractXmlContentFromZfo = (zfoContent) => {
      const pkcs7Der = forge.util.createBuffer(zfoContent, 'binary');
      const pkcs7Asn1 = forge.asn1.fromDer(pkcs7Der);
      const pkcs7 = forge.pkcs7.messageFromAsn1(pkcs7Asn1);

      let xmlContentParts = pkcs7.rawCapture.content.value[0].value;
      let xmlContent = xmlContentParts.map(part => part.value).join('');
      return xmlContent;
    }

    const transformData = (xmlContent) => {
      const listStylesheet = `
    <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
      <xsl:output omit-xml-declaration="yes"/>
      <xsl:template match="/">
        <xsl:for-each select="//*[local-name()='dmFile']">
          <xsl:value-of select="@dmFileDescr"/>
          <xsl:text>&#xa;</xsl:text>
        </xsl:for-each>
      </xsl:template>
    </xsl:stylesheet>`;
      const fileNames = transformXml(xmlContent, listStylesheet).trim().split('\n');

      fileNames.forEach((file) => {
        const dumpStylesheet = `
      <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
        <xsl:output omit-xml-declaration="yes"/>
        <xsl:template match="/">
          <xsl:value-of select="//*[local-name()='dmFile' and @dmFileDescr='${file}']/*[local-name()='dmEncodedContent']/text()"/>
        </xsl:template>
      </xsl:stylesheet>`;

        const encodedContent = transformXml(xmlContent, dumpStylesheet);
        const decodedContent = atob(encodedContent);
        const byteArray = new Uint8Array(decodedContent.length);
        for (let i = 0; i < decodedContent.length; i++) {
          byteArray[i] = decodedContent.charCodeAt(i);
        }

        const blob = new Blob([byteArray], { type: "application/pdf" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = file;
        a.textContent = `Download ${file}`;
        a.className = "bg-green-500 text-white py-2 px-4 rounded-md block mt-2";
        document.body.appendChild(a);
      });
    }

    const transformXml = (xmlContent, xsltString) => {
      const parser = new DOMParser();
      const xsltProcessor = new XSLTProcessor();

      const xslStylesheet = parser.parseFromString(xsltString, "application/xml");
      xsltProcessor.importStylesheet(xslStylesheet);

      const xmlDoc = parser.parseFromString(xmlContent, "application/xml");
      const fragment = xsltProcessor.transformToFragment(xmlDoc, document);

      const serializer = new XMLSerializer();
      return serializer.serializeToString(fragment);
    }
  </script>
</body>

</html>